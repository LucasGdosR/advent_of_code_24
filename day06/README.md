This was an interesting challenge. It is remarkably computationally intensive, comparing to the previous ones. There are many memes on reddit regarding how much the infinite loop detection takes to run, making you wonder if you're in an infinite loop yourself. My first implementation in python tried to add obstacles in every space in the grid, but then I figured only obstacles in the guard's original path may change it. With this approach it took 17 seconds to run. Still a lot, but much better.

This made me especially interested in making it fast in my C implementation. In my first single-threaded implementation, I got it down to 160 ms with a cold start. I refined the number types, using 8 bits and 16 bits unsigned integers where appropriate, passed some arguments by value rather than by reference, and turned some counters into global variables instead of passing references to them, which further reduced it to 119 ms with a cold start, a 26% decrease. With a little warmup, the fastest run took 108 ms. I made it multithreaded (4 threads), reaching 61 ms with cold starts, and 58 with a warmup. Finally, I implemented Floyd's algorithm instead of storing states in a set, and got to 20ms cold starts with 4 threads, and 18 ms after a warmup.

Main takeaways:
1. Part 1
- Incrementing enums directly to change state is pretty cool in C. Not all languages allow that, but you can use a table and index into it using the value of the enum (done in the python implementation);
- Know your data, yada yada (check previous days for more details);
- This is a pretty basic AI implementation of an agent with states and actions. The guard moves according to its state, and changes state based on encountering obstacles.
2. Part 2
- This is a problem of cycle detection. This implementation recorded seen states in a hashtable, and detected a cycle whenever visiting a state that was already seen. It can also be solved by Floyd's algorithm (Tortoise and Hare), which I included in python both approaches led to similar time to complete, but Floyd's algorithm uses much less memory, so it's probably the best approach;
- Hashset implementation: there's a hashtable with a linked list on each slot of the hashtable. This implementation uses a prime number for the hashtable size (10,007), and a simple hash function to combine three integers and spread them along the table. The hashset is implemented with an arena, requiring no dynamic memory allocations, and allowing blazingly fast reutilization of the same memory. Whenever I need a fresh state, `set_init` sets `arena_alloc_pos` to `0`, and all the memory is effectively free, with no need for calling `malloc` later. This is, by far, the best use of an arena in my implementations of the Advent of Code so far;
- This part requires starting from a fresh state each iteration. The guard must always start from the same spot, and the map must always have obstacles at the same places. Any mutation must be undone, as is the case of `input`, and initial state should be cached, as is the case of `initial_guard`;
- The use of smaller integers resulted in a 12,5% decrease in runtime, and an even greater reduction in memory usage. Using 8 bits and 16 bits integers can lead to significant benefits, but you must... know your data;
- Using smaller integers also led to a `struct guard` that's smaller than a pointer, making more sense to pass guards by value rather than by reference to functions that don't perform side-effects / keep state. This also led to a significant speedup, probably partly because the compiler can make stronger assumptions that lead to better optimizations;
- Going by the compiler optimization line of reasoning, instead of passing pointers to `visited` and `loops_found`, I turned them into global variables, and there was a slight speedup;
- Multithreaded implementation: threads share work by each getting an unique integer from a shared atomic counter, and using the index to pick up some data from a shared pointer. Each of them accumulates work in a local variable, and returns it to the main thread, which reduces the work to a single value. Some changes were made to make variables immutable, allowing synchronization-free access of them by multiple threads. Variables that needed to be written to were made local to each thread;
- Floyd's algorithm: honestly, this is the better tool for the job, but the set implementation has better teaching value. Anyway, here's an implementation of the Tortoise and Hare algorithm that uses 2 paddings of sentinels to avoid dealing with edge cases.
